不同时期进行分表策略
如果当项目运行到一定时间后再进行分表
1.分表后将现有数据进行迁移分布到多张表(通常不推荐,只有在单张表太大,拖累到正常的项目运行时才对数据进行迁移)
缺点 需要服务器停止服务
2.做查询路由,如果id<某个值(分表前的最后一条记录),直接查原始表,如果id大于某值,那么按照我们设定的分表规则计算表后缀.

如果是uuid类型的id,无法直接比较大小,

v1





opcache php5.5默认安装
xcache  php5.4 linux下   
wincache   windows下
APC php5.4


APCU xcache  wincache   支持php  API调用  (默认情况下 效率高于memcache)

客户端缓存
静态资源引用公共服务器资源,js css等文本文件进行压缩
通常合并多个js  或css文件能降低带宽消耗
但当被合并的文件都很大的情况下,合并文件会增加网络访问延迟

开发测试的时候,防止浏览器缓存带来的问题,给静态资源加 参数时间戳带尾巴
在发行产品的时候带版本号




局域网缓存



网络缓存
CDN
多节点DNS动态解析
静态资源负载均衡
基于URI
p2p  用户端缓存与资源共享   适用于下载资源共享  讯雷(吸血)


硬盘缓存
页面缓存
    模板编译
    php输出缓存 
    生成静态
文件数据缓存
    return Array();
    JSON/XML数据缓存;
    二进制文件缓存;

静态文件命中率


内存(对象,数据结构)
memcache 优于APCU xcache  wincache,
第一memcache 可以独立安装运行
第二memcache  能通过网络提供缓存服务
为php集群负载均衡提供服务
操作简单
高效率的内存缓存
Redis  支持集群与大数据
如果缓存命中率能达到100%,基本可以消除数据库查询效率产生的问题.


数据库缓存(表)
作为最低级别缓存本质上依然存在数据据库中
通常使用内存表来做缓存
数据量不会太大
使用频繁度极高
优势 :  依然使用sql语句进行查询,开发者可以忽略缓存的存在



